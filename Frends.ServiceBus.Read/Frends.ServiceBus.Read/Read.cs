using System;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;
using Frends.ServiceBus.Read.Definitions;
using Microsoft.Azure.ServiceBus;
using Microsoft.Azure.ServiceBus.Core;
using System.Text;
using Microsoft.Azure.ServiceBus.Management;
using Microsoft.Azure.ServiceBus.InteropExtensions;
using System.Net.Mime;
using System.Linq;

namespace Frends.ServiceBus.Read;

/// <summary>
/// Azure Service Bus task.
/// </summary>
public class ServiceBus
{
    /// <summary>
    /// Read message from Azure Service Bus queue or subscription.
    /// </summary>
    /// <param name="input">Input parameters</param>
    /// <param name="options">Options parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>Object { bool ReceivedMessage, string Content, string ContentType, string SessionId, string MessageId, string CorrelationId, int DeliveryCount, long EnqueuedSequenceNumber, long SequenceNumber, string Label, Dictionary&lt;string, object&gt; Properties }, string ReplyTo, string ReplyToSessionId, long Size, string To, DateTime ScheduledEnqueueTimeUtc</returns>
    public static async Task<Result> Read([PropertyTab] Input input, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (options.CreateQueueOrSubscriptionIfItDoesNotExist)
        {
            var deleteIdle = TimeSpan.Zero;

            if (options.AutoDeleteOnIdle > 0)
            {
                switch (options.TimeFormat)
                {
                    case TimeFormat.Minutes:
                        deleteIdle = options.AutoDeleteOnIdle > 5 ? TimeSpan.FromMinutes(options.AutoDeleteOnIdle) : TimeSpan.FromMinutes(5); ; break;
                    case TimeFormat.Hours:
                        deleteIdle = options.AutoDeleteOnIdle > 0.0833333333 ? TimeSpan.FromHours(options.AutoDeleteOnIdle) : TimeSpan.FromMinutes(5); break;
                    case TimeFormat.Days:
                        deleteIdle = options.AutoDeleteOnIdle > 0.00347222222 ?  TimeSpan.FromDays(options.AutoDeleteOnIdle) : TimeSpan.FromMinutes(5) ; break;
                }
            }

            switch (input.SourceType)
            {
                case QueueOrSubscription.Queue:
                    if (string.IsNullOrWhiteSpace(input.QueueOrTopicName) || string.IsNullOrWhiteSpace(input.ConnectionString)) throw new Exception("Queue or topic name and connection string required.");
                    await EnsureQueueExists(input.QueueOrTopicName, input.ConnectionString, deleteIdle, options.MaxSize, cancellationToken);
                    break;
                case QueueOrSubscription.Subscription:
                    if (string.IsNullOrWhiteSpace(input.QueueOrTopicName) || string.IsNullOrWhiteSpace(input.SubscriptionName) || string.IsNullOrWhiteSpace(input.ConnectionString)) throw new Exception("Queue or topic name, subscription name and connection string required.");
                    await EnsureTopicExists(input.ConnectionString, input.QueueOrTopicName, input.SubscriptionName, deleteIdle, options.MaxSize, cancellationToken);
                    break;
                default:
                    throw new Exception($"Unexpected destination type: {input.SourceType}");
            }
        }

        var result = await DoReadOperation(input, options, cancellationToken);
        return new Result(result);
    }


    private static async Task EnsureQueueExists(string queueOrTopicName, string connectionString, TimeSpan deleteIdle, int MaxSize, CancellationToken cancellationToken)
    {
        var manager = new ManagementClient(connectionString);
        QueueDescription queueDescription;

        if (!await manager.QueueExistsAsync(queueOrTopicName, cancellationToken).ConfigureAwait(false))
        {
            if(deleteIdle == TimeSpan.Zero)
            {
                queueDescription = new QueueDescription(queueOrTopicName)
                {
                    EnableBatchedOperations = true,
                    MaxSizeInMB = MaxSize,
                };
            }
            else
            {
                queueDescription = new QueueDescription(queueOrTopicName)
                {
                    EnableBatchedOperations = true,
                    MaxSizeInMB = MaxSize,
                    AutoDeleteOnIdle = deleteIdle,
                };
            }
            await manager.CreateQueueAsync(queueDescription, cancellationToken).ConfigureAwait(false);
        }
    }

    private static async Task EnsureTopicExists(string connectionString, string queueOrTopicName, string subscriptionName, TimeSpan deleteIdle, int maxSize, CancellationToken cancellationToken)
    {
        var managementClient = new ManagementClient(connectionString);
        TopicDescription topicDescription;

        if (!await managementClient.TopicExistsAsync(queueOrTopicName, cancellationToken).ConfigureAwait(false))
        {
            if (deleteIdle == TimeSpan.Zero)
            {
                topicDescription = new TopicDescription(queueOrTopicName)
                {
                    EnableBatchedOperations = true,
                    MaxSizeInMB = maxSize,
                };
            }
            else
            {
                topicDescription = new TopicDescription(queueOrTopicName)
                {
                    EnableBatchedOperations = true,
                    MaxSizeInMB = maxSize,
                    AutoDeleteOnIdle = deleteIdle,
                };
            }
            await managementClient.CreateTopicAsync(topicDescription, cancellationToken).ConfigureAwait(false);
        }
        await EnsureSubscriptionExists(queueOrTopicName, subscriptionName, connectionString, deleteIdle, cancellationToken);
    }

    private static async Task EnsureSubscriptionExists(string queueOrTopicName, string subscriptionName, string connectionString, TimeSpan deleteIdle, CancellationToken cancellationToken)
    {
        var manager = new ManagementClient(connectionString);
        SubscriptionDescription subscriptionDescription;

        if (!await manager.SubscriptionExistsAsync(queueOrTopicName, subscriptionName, cancellationToken).ConfigureAwait(false))
        {
            if (deleteIdle == TimeSpan.Zero)
            {
                subscriptionDescription = new SubscriptionDescription(queueOrTopicName, subscriptionName)
                {
                    EnableBatchedOperations = true,
                };
            }
            else
            {
                subscriptionDescription = new SubscriptionDescription(queueOrTopicName, subscriptionName)
                {
                    EnableBatchedOperations = true,
                    AutoDeleteOnIdle = deleteIdle,
                };
            }
            await manager.CreateSubscriptionAsync(subscriptionDescription, cancellationToken).ConfigureAwait(false);
        }
    }


    private static async Task<ReadResult> DoReadOperation(Input input, Options options, CancellationToken cancellationToken)
    {
        ServiceBusConnection connection = null;
        MessageReceiver requestClient = null;

        var path = input.SourceType == QueueOrSubscription.Subscription ? $"{input.QueueOrTopicName}/subscriptions/{input.SubscriptionName}" : input.QueueOrTopicName;
        var timeout = TimeSpan.FromSeconds(options.TimeoutSeconds);

        try
        {
            if (options.UseCachedConnection)
                requestClient = ServiceBusMessagingFactory.Instance.GetMessageReceiver(input.ConnectionString, path, timeout);
            else
            {
                connection = ServiceBusMessagingFactory.CreateConnectionWithTimeout(input.ConnectionString, timeout);
                requestClient = new MessageReceiver(connection, path);
            }

            cancellationToken.ThrowIfCancellationRequested();
            var msg = await requestClient.ReceiveAsync();

            if (msg == null)
            {
                return new ReadResult
                {
                    ReceivedMessage = false
                };
            }

            var result = new ReadResult
            {
                ReceivedMessage = true,
                ContentType = msg.ContentType,
                Properties = msg.UserProperties?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value),
                SessionId = msg.SessionId,
                MessageId = msg.MessageId,
                CorrelationId = msg.CorrelationId,
                Label = msg.Label,
                DeliveryCount = msg.SystemProperties.DeliveryCount,
                EnqueuedSequenceNumber = msg.SystemProperties.EnqueuedSequenceNumber,
                SequenceNumber = msg.SystemProperties.SequenceNumber,
                ReplyTo = msg.ReplyTo,
                ReplyToSessionId = msg.ReplyToSessionId,
                Size = msg.Size,
                To = msg.To,
                ScheduledEnqueueTimeUtc = msg.ScheduledEnqueueTimeUtc,
                Content = ReadMessageBody(msg, options),
            };
            return result;
        }
        finally
        {
            await (requestClient?.CloseAsync() ?? Task.CompletedTask);
            await (connection?.CloseAsync() ?? Task.CompletedTask);
        }
    }

    private static string ReadMessageBody(Message msg, Options options)
    {
        if (options.BodySerializationType == BodySerializationType.String)
            return msg.GetBody<string>();

        Encoding encoding = GetEncodingFromContentType(msg.ContentType, options.DefaultEncoding);

        if (options.BodySerializationType == BodySerializationType.ByteArray)
        {
            var messageBytes = msg.GetBody<byte[]>();
            return messageBytes == null ? null : encoding.GetString(messageBytes);
        }

        if (options.BodySerializationType == BodySerializationType.Stream)
        {
            var messageBytes = msg.Body;
            return messageBytes == null ? null : encoding.GetString(messageBytes);
        }

        throw new ArgumentException($"Unsupported BodySerializationType: {options.BodySerializationType}");
    }

    private static Encoding GetEncodingFromContentType(string contentTypeString, MessageEncoding encodingChoice)
    {

        Encoding encoding = null;

        switch (encodingChoice)
        {
            case MessageEncoding.UTF8:
                encoding = Encoding.UTF8;
                break;
            case MessageEncoding.UTF32:
                encoding = Encoding.UTF32;
                break;
            case MessageEncoding.ASCII:
                encoding = Encoding.ASCII;
                break;
            case MessageEncoding.Unicode:
                encoding = Encoding.Unicode;
                break;
            case MessageEncoding.Latin1:
                encoding = Encoding.Latin1;
                break;
            case MessageEncoding.BigEndianUnicode:
                encoding = Encoding.BigEndianUnicode;
                break;
        };

        if (!string.IsNullOrEmpty(contentTypeString))
        {
            var contentType = new ContentType(contentTypeString);
            if (!string.IsNullOrEmpty(contentType.CharSet))
                encoding = Encoding.GetEncoding(contentType.CharSet);
        }
        return encoding;
    }

}



