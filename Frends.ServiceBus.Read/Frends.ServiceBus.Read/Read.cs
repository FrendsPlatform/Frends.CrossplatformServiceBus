using System;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;
using Frends.ServiceBus.Read.Definitions;
using Microsoft.Azure.ServiceBus;
using Microsoft.Azure.ServiceBus.Core;
using Microsoft.Azure.ServiceBus.Management;
using System.Linq;
using System.Collections.Generic;

namespace Frends.ServiceBus.Read;

/// <summary>
/// Azure Service Bus task.
/// </summary>
public static class ServiceBus
{
    /// <summary>
    /// Read message from Azure Service Bus queue or topic.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.ServiceBus.Read)
    /// </summary>
    /// <param name="input">Input parameters</param>
    /// <param name="options">Options parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>List { bool receivedMessage, string contentType, Dictionary&lt;string, object&gt; properties, string sessionId, string messageId, string correlationId, string label, int deliveryCount, long enqueuedSequenceNumber, long sequenceNumber, string replyTo, string replyToSessionId, long size, string to, DateTime scheduledEnqueueTimeUtc, string content}</returns>
    public static async Task<Result> Read([PropertyTab] Input input, [PropertyTab] Options options,
        CancellationToken cancellationToken)
    {
        if (options.CreateQueueOrTopicIfItDoesNotExist)
        {
            var deleteIdle = TimeSpan.Zero;

            if (options.AutoDeleteOnIdle > 0)
            {
                switch (options.TimeFormat)
                {
                    case TimeFormat.Minutes:
                        deleteIdle = options.AutoDeleteOnIdle > 5
                            ? TimeSpan.FromMinutes(options.AutoDeleteOnIdle)
                            : TimeSpan.FromMinutes(5);
                        break;
                    case TimeFormat.Hours:
                        deleteIdle = options.AutoDeleteOnIdle > 0.0833333333
                            ? TimeSpan.FromHours(options.AutoDeleteOnIdle)
                            : TimeSpan.FromMinutes(5);
                        break;
                    case TimeFormat.Days:
                        deleteIdle = options.AutoDeleteOnIdle > 0.00347222222
                            ? TimeSpan.FromDays(options.AutoDeleteOnIdle)
                            : TimeSpan.FromMinutes(5);
                        break;
                }
            }

            switch (input.SourceType)
            {
                case QueueOrTopic.Queue:
                    if (string.IsNullOrWhiteSpace(input.QueueOrTopicName) ||
                        string.IsNullOrWhiteSpace(input.ConnectionString))
                        throw new Exception("Connection parameters required.");
                    await EnsureQueueExists(input.QueueOrTopicName, input.ConnectionString, deleteIdle, options.MaxSize,
                        cancellationToken);
                    break;
                case QueueOrTopic.Topic:
                    if (string.IsNullOrWhiteSpace(input.QueueOrTopicName) ||
                        string.IsNullOrWhiteSpace(input.SubscriptionName) ||
                        string.IsNullOrWhiteSpace(input.ConnectionString))
                        throw new Exception("Connection parameters required.");
                    await EnsureTopicExists(input.ConnectionString, input.QueueOrTopicName, input.SubscriptionName,
                        deleteIdle, options.MaxSize, cancellationToken);
                    break;
                default:
                    throw new Exception($"Unexpected destination type: {input.SourceType}");
            }
        }

        var result = await DoReadOperation(input, options);
        return new Result { Results = result };
    }


    private static async Task EnsureQueueExists(string queueOrTopicName, string connectionString, TimeSpan deleteIdle,
        int maxSize, CancellationToken cancellationToken)
    {
        var manager = new ManagementClient(connectionString);
        var doesQueryExists = await manager.QueueExistsAsync(queueOrTopicName, cancellationToken);

        if (!doesQueryExists)
        {
            var queueDescription = new QueueDescription(queueOrTopicName)
            {
                EnableBatchedOperations = true,
                MaxSizeInMB = maxSize,
            };

            if (deleteIdle != TimeSpan.Zero)
            {
                queueDescription.AutoDeleteOnIdle = deleteIdle;
            }

            await manager.CreateQueueAsync(queueDescription, cancellationToken);
        }
    }

    private static async Task EnsureTopicExists(string connectionString, string queueOrTopicName,
        string subscriptionName, TimeSpan deleteIdle, int maxSize, CancellationToken cancellationToken)
    {
        var managementClient = new ManagementClient(connectionString);
        var topic = await managementClient.GetTopicAsync(queueOrTopicName, cancellationToken).ConfigureAwait(false);
        topic.EnableBatchedOperations = true;
        topic.MaxSizeInMB = maxSize;
        if (deleteIdle != TimeSpan.Zero)
        {
            topic.AutoDeleteOnIdle = deleteIdle;
        }

        await managementClient.UpdateTopicAsync(topic, cancellationToken);

        await EnsureSubscriptionExists(queueOrTopicName, subscriptionName, connectionString, deleteIdle,
            cancellationToken);
    }

    private static async Task EnsureSubscriptionExists(string queueOrTopicName, string subscriptionName,
        string connectionString, TimeSpan deleteIdle, CancellationToken cancellationToken)
    {
        var manager = new ManagementClient(connectionString);

        var subscription = await manager.GetSubscriptionAsync(queueOrTopicName, subscriptionName, cancellationToken)
            .ConfigureAwait(false);
        subscription.EnableBatchedOperations = true;
        if (deleteIdle != TimeSpan.Zero)
        {
            subscription.AutoDeleteOnIdle = deleteIdle;
        }

        await manager.UpdateSubscriptionAsync(subscription, cancellationToken);
    }

    private static async Task<List<ReadResult>> DoReadOperation(Input input, Options options)
    {
        ServiceBusConnection connection = null;
        MessageReceiver requestClient = null;

        var path = input.SourceType == QueueOrTopic.Topic
            ? $"{input.QueueOrTopicName}/subscriptions/{input.SubscriptionName}"
            : input.QueueOrTopicName;
        var timeout = TimeSpan.FromSeconds(options.TimeoutSeconds);

        try
        {
            var result = new List<ReadResult>();

            if (options.UseCachedConnection)
                requestClient =
                    ServiceBusMessagingFactory.Instance.GetMessageReceiver(input.ConnectionString, path, timeout);
            else
            {
                connection = ServiceBusMessagingFactory.CreateConnectionWithTimeout(input.ConnectionString, timeout);
                requestClient = new MessageReceiver(connection, path);
            }

            var msg = await requestClient.ReceiveAsync();

            if (msg == null)
                result.Add(new ReadResult(false));
            else
            {
                result.Add(new ReadResult(
                    true,
                    msg.ContentType,
                    msg.UserProperties?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value),
                    msg.SessionId,
                    msg.MessageId,
                    msg.CorrelationId,
                    msg.Label,
                    msg.SystemProperties.DeliveryCount,
                    msg.SystemProperties.EnqueuedSequenceNumber,
                    msg.SystemProperties.SequenceNumber,
                    msg.ReplyTo,
                    msg.ReplyToSessionId,
                    msg.Size,
                    msg.To,
                    msg.ScheduledEnqueueTimeUtc,
                    MessageReader.Read(msg, options.BodySerializationType, options.DefaultEncoding)
                ));
            }

            return result;
        }
        finally
        {
            await (requestClient?.CloseAsync() ?? Task.CompletedTask);
            await (connection?.CloseAsync() ?? Task.CompletedTask);
        }
    }
}